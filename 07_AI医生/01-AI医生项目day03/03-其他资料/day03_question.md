- 考试题1 (10分): 给定一个整形数组，是否能找出其中的两个数使得其和为某个指定的值? 在第一天代码的基础上分析你的时间复杂度, 然后进行改进达到O(n)
  
  - ```
    # 函数调用格式如下
    def main():
        array = [11, 7, 45, 67, 134, 5, 83, 55, 106, 33, 57, 82, 6, 24, 87, 61, 3, 39, 6, 26]
        target_number = 13
        result, a, b = hasSum(array, target_number)
        if result == 1:
            print('YES, %d + %d = %d' % (a, b, target_number))
        else:
            print('NO')
    
    
    if __name__ == '__main__':
        main()
    ```
    
    



- 考试题2 (10分): 给出一个单向链表的头指针, 如果链表有环, 则返回环的长度, 否则返回0.

  - 示例: head -> 3 -> 8 -> 7 -> 1 -> 2 -> 3 -> 4 -> 5 -> 1, 则返回5

  - ```
    # 链表的类定义如下:
    class ListNode(object):
        def __init__(self, value=0):
            self.value = value
            self.next_node = None
    ```

  - ```
    from ListModel import ListNode
    
    def main():
        # 下面完成构造链表的代码
        TODO code!!!
        # 调用你编写的代码函数, 唯一的参数是头指针head
        res = lengthOfCircle(head)
        print('result length:', res)
    
    if __name__ == '__main__':
        main()
    ```





- 考试题3 (10分): 给定一个数组，找出最少元素，使得将其删除后，剩下的元素是递增有序的。(提示: 本质上就是寻找最长递增子序列)

  - 示例: 给定数组A = [4, 2, 3, 7, 5, 1], 删除掉3个元素4, 7, 1后, 剩下的[2, 3, 5]就是满足要求的最长递增子序列。

  - ```
    def main():
        a = [4, 2, 3, 7, 5, 1]
        res, max_num = get_max_ascent_sequence(a)
        # res: 最长递增子序列, max_num: 该序列的长度
        print(res)
        print(max_num)
    
    
    if __name__ == '__main__':
        main()
    ```

    



- 考试题4 (10分): 
  - 1: 谈一谈对fasttext的认识, 能做什么? 原理是什么? 相比于word2vec有什么优势?
  - 2: 为什么要用fasttext做文本分类? 是因为训练快还是预测快? 还有什么其他原因?





- 考试题5 (20分): 
  - 1: 词向量都有哪些表示方法? 
  - 2: 经典的方法 or 你自己理解的方法是如何训练词向量的? (尽量详细描述, 甚至于需要哪些超参数的设置, 以及设置多少, 为什么这样设置?)
  - 3: 这种训练是有监督还是无监督, 如何理解?
  - 4: 训练好的词向量如何评价? (大胆的说出你的想法)
  - 5: 你的方法可以解决一词多义的问题吗? (苹果, 杯具), 如果能为什么? 如果不能有何改进方法?



- 考试题6 (40分): 优化并改进我们的第一个命名实体审核模型
  - 1: 明确提出你自己的优化点，改动代码 + 训练模型
  - 2: 分析改进后的数据指标，如果提升了为什么？如果下降了为什么？如果很难改进为什么？记录你所遇到的困难。
  - 3: 改进的.txt文件说明, 代码文件, 结果展示截图, 放在一起打包提交。